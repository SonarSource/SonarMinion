{"description":"When a method invocation is done with a method invocation argument within a try block, the modelization of CFG that can lead to an exception for the argument will end up creating a block where the identifier of the method select expression will be evaluated. \r\n\r\nThis lead to a wrong LVA where the variable on which the outer invocation is made will be considered dead at method invocation instruction. \r\n\r\nThe consequence is that lockNotUnlockedCheck can fail with a null pointer exception in this case because the SV will be wept out of the program state as it is considered dead.\r\n\r\n{code:title\u003dTestcase for LVA}\r\n  @Test\r\n  public void liveness_of_mse_of_method_invocation() throws Exception {\r\n    CFG cfg \u003d buildCFG(\"void foo(String s) {A a; A b; try { a.foo(b.toString()); } catch(Exception e) {}} \");\r\n    LiveVariables liveVariables \u003d LiveVariables.analyze(cfg);\r\n    System.out.println(CFGDebug.toString(cfg));\r\n    assertThat(liveVariables.getIn(cfg.reversedBlocks().get(3))).hasSize(2).extracting(\"name\").contains(\"a\", \"b\");\r\n    assertThat(liveVariables.getOut(cfg.reversedBlocks().get(3))).extracting(\"name\").contains(\"a\");\r\n  }\r\n{code}\r\n\r\n{code:title\u003dTestcase LocksNotUnlocked}\r\n// raise a null pointer exception as lock variable is considered dead after evaluating the argument and removed from program state.\r\n  class wrong_lva_lead_to_npe {\r\n    void fun(Object info) {\r\n      Lock lock;\r\n      try {\r\n        return lock.tryLock(info.toString(), info.toString());\r\n      } catch (Exception e) {\r\n        e.printStackTrace();\r\n      }\r\n    }\r\n  }\r\n{code}\r\n\r\nNote : this issue was raised by analyzing [Jgroups|https://github.com/belaban/JGroups] which should be added to peach (SonarSource QA instance) once this issue is solved.","component":"SonarJava","component_version":""}