{"description":"In the following code, two issues are heavily tied to each other. RSPEC-2259 identifies a null pointer (and interrupt the execution path), and RSPEC-2583 consequently identifies a condition being always false, as the only way to reach this point is by having {{ob}} not null.\r\n\r\nBoth issues are correct, with following messages:\r\n\r\n* NPE:\r\n## Implies \u0027obj\u0027 can be null. (on method parameter)\r\n## \u0027obj\u0027 is dereferenced.\r\n\r\n* Condition always false:\r\n## Implies \u0027obj\u0027 {color:red}can not be null{color}. (on method parameter)\r\n## Expression is always false.\r\n\r\nThe problem comes from the fact that flow message {{can not be null}} is misleading, because it wrongly implies that there ONLY the null path possible, which is not the case. Message associating the non-null constraint should be updated for the parameter to make it less strict.\r\n\r\n{code}\r\nabstract class A {\r\n  @Override\r\n  public boolean equals(Object obj) {\r\n    if (this \u003d\u003d obj) {\r\n      return true;\r\n    }\r\n    if (this.getClass() !\u003d obj.getClass()) { // Issue squid:S2259 (Null pointer on \"obj.\")\r\n      return false;\r\n    }\r\n    if (obj \u003d\u003d null) { // Issue squid:S2583 (condition always false)\r\n      return false;\r\n    }\r\n    return testSomething();\r\n  }\r\n\r\n  abstract boolean testSomething();\r\n}\r\n{code}","component":"SonarJava","component_version":""}