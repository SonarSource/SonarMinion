{"description":"The return type of a conditional expression is not properly resolved and lead to unresolved methods when primitives and non-primitives types are mixed, as well as when deferred and non-deferred types.\r\n\r\n{code}\r\nimport java.util.Set;\r\nimport java.util.stream.Collectors;\r\nimport java.util.stream.Stream;\r\n\r\nclass A {\r\n  void foo(Set\u003cString\u003e set) {\r\n\r\n    set.stream()\r\n      .flatMap(key -\u003e key.startsWith(\"hello\") ? Stream.empty() : Stream.of(Integer.parseInt(key)))\r\n      .collect(Collectors.toList()) // collect is not resolved\r\n      .forEach(A::bar);\r\n\r\n    set.stream()\r\n      .map(key -\u003e key.startsWith(\"hello\") ? key : key.length())\r\n      .collect(Collectors.toList()) // collect is not resolved\r\n      .forEach(A::foo);\r\n  }\r\n\r\n  private static void bar(Integer i) { } // method marked as unused\r\n  private static void foo(Object o) { } // method marked as unused\r\n}\r\n{code}","component":"SonarJava","component_version":"4.2.1"}