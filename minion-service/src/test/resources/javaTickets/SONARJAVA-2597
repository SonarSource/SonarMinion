{"description":"When call to {{Optional.get()}} is detected in OptionalGetBeforeIsPresentCheck  without calling {{Optional.isPresent()}} we should not terminate the exploration of the method, only issue should be reported and exceptional yield should be created. The happy path is still possible.\r\n\r\nCurrent implementation terminates the exploration which creates only exceptional yields for some methods which are calling {{Optional.get}}.\r\n\r\n{code}\r\n private int test(Optional\u003cInteger\u003e op) {\r\n    op.get(); // creates only exceptional yields\r\n  }\r\n\r\n  private boolean call(Optional\u003cInteger\u003e op) {\r\n    return test(op) \u003d\u003d 0;  // call to test enqueues only exceptions\r\n  }\r\n{code}\r\n\r\nOther example with many side effects:\r\n{code}\r\nabstract class A {\r\n\r\n  public void foo(boolean b) {\r\n    if (bar(b)) { // FP S2583 (condition always false)\r\n      doSomething(42);\r\n    }\r\n  }\r\n\r\n  private boolean bar(boolean b) { // FP S3516 (method returning always the same value)\r\n    if (b) {\r\n      Optional\u003cObject\u003e value \u003d getValue();\r\n      doSomething(value.get()); // legit issue S3655, but interrupting SE engine\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  public abstract void doSomething(Object o);\r\n  public abstract Optional\u003cObject\u003e getValue();\r\n}\r\n{code}\r\n\r\nIn the code above, by allowing the engine to continue after raising the issue, it will:\r\n- allow implementation of RSPEC-3516 to identify the two existing exit path, with different values, removing the FP on method {{bar}}.\r\n- allow the engine to compute 2 distinct happy path method yields instead of a single one.\r\n- remove the FP from S2583, as multiple yield can now be used, with different outcomes\r\n- keep legit issue from S3655","component":"SonarJava","component_version":"5.1.1"}