{"description":"With Java 8, the target type of a method invocation can influence type inference. In following code, the 2nd invocation to {{useSet}} compile, as the inferred return type has been influenced by the target type, and not only the parameters.\r\n\r\nIn java 7, both invocations to {{useSet}} don\u0027t compile. \r\n\r\n{code}\r\nimport java.util.HashSet;\r\n\r\ninterface I {}\r\nclass A implements I {}\r\n\r\nclass Test {\r\n  void methodCall(A a) {\r\n    HashSet\u003cA\u003e newHashSet \u003d newHashSet(a, a);\r\n\r\n    useSet(newHashSet); // does not compile\r\n    useSet(newHashSet(a, a)); // compile, type inference has been influenced by target type\r\n  }\r\n\r\n  \u003cE\u003e java.util.HashSet\u003cE\u003e newHashSet(E... elements) {\r\n    return null;\r\n  }\r\n\r\n  void useSet(java.util.Set\u003cI\u003e elements) {}\r\n}\r\n{code}\r\n\r\nFrom the JLS8 §18:\r\n{quote}\r\nIn comparison to the Java SE 7 Edition of The Java® Language Specification, important changes to inference include:\r\n\r\n* Adding support for lambda expressions and method references as method invocation arguments.\r\n\r\n* Generalizing to define inference in terms of poly expressions, which may not have well-defined types until after inference is complete. This has the notable effect of improving inference for nested generic method and diamond constructor invocations.\r\n\r\n* Describing how inference is used to handle wildcard-parameterized functional interface target types and most specific method analysis.\r\n\r\n* Clarifying the distinction between invocation applicability testing (which involves only the invocation arguments) and *invocation type inference (which incorporates a target type)*.\r\n\r\n* Delaying resolution of all inference variables, even those with lower bounds, until invocation type inference, in order to get better results.\r\n\r\n* Improving inference behavior for interdependent (or self-dependent) variables.\r\n\r\n* Eliminating bugs and potential sources of confusion. This revision more carefully and precisely handles the distinction between specific conversion contexts and subtyping, and describes reduction by paralleling the corresponding non-inference relations. Where there are intentional departures from the non-inference relations, these are explicitly identified as such.\r\n\r\n* Laying a foundation for future evolution: enhancements to or new applications of inference will be easier to integrate into the specification.\r\n{quote}\r\n","component":"SonarJava","component_version":""}