{"description":"Because we currently only apply {{NOT_NULL}} constraint a {{final}} field when its initializer is a new class tree, or a new array, we end up learning that a constant can be {{null}}, despite the fact that the initializer was a (non-null) literal.\r\n\r\nA {{final}} field should also be initialized with {{NOT_NULL}} constraint when its initializer +is present+ and is:\r\n* any expression, if field of primitive type,\r\n* any expression, as long as it\u0027s type is a primitive type,\r\n* a string literal, \r\n* an invoked method annotated with {{@javax.annotation.Nonnull}}.\r\n\r\nExample of FP currently raised:\r\n{code}\r\nabstract class A {\r\n\r\n  void foo(String a) {\r\n    String b \u003d a;\r\n    if (b \u003d\u003d null) {\r\n      b \u003d MY_CONSTANT;\r\n    }\r\n    if (b \u003d\u003d null \u0026\u0026 testSomething()) {\r\n      foo();\r\n    } else if (MY_CONSTANT.equalsIgnoreCase(b)) { // FP Null dereference: A \"NullPointerException\" could be thrown; \"MY_CONSTANT\" is nullable here.\r\n      bar();\r\n    }\r\n  }\r\n\r\n  private static final String MY_CONSTANT \u003d \"value\";\r\n\r\n  abstract boolean testSomething();\r\n  abstract void foo();\r\n  abstract void bar();\r\n}\r\n{code}","component":"SonarJava","component_version":"4.12"}