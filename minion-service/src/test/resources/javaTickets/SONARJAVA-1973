{"description":"In the following example, the symbolic execution engine will never reach the state where the method actually returns {{true}}.\r\n\r\nBy construction of how we handle branches, the first time we will reach the state where we assign {{true}} to {{result}} will be when doing a second passage in the {{foreach}} loop. As we limit the number of passages in loops as well, we will not go further after handling the assignment.\r\n\r\nNow, the state prior to the assignment can also be reach on another branch of the exploded graph, being not as far in number of passages in the loop. Unfortunately, when hitting this state and trying to enqueuing the it, we will hit the cache (with the previous node which is a dead end) and stop the exploration. \r\n\r\nNumber of visits are not taken into account when getting nodes from the cache.\r\n\r\n{code}\r\n  class ForEachLoop {\r\n    private static boolean count(java.util.List\u003cString\u003e words) {\r\n      boolean result \u003d false;\r\n      for (String word : words) {\r\n        if (isWord(word)) {\r\n          result \u003d true;\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n     * yields: \r\n     *   [{params: [NOT_NULL], result: null (-1), exceptional: false}, \r\n     *    {params: [NOT_NULL], result: FALSE (-1), exceptional: false}]\r\n     */\r\n    private static boolean isWord(String word) {\r\n      return word.startsWith(\"hello\") \u0026\u0026 word.endsWith(\"word\");\r\n    }\r\n  }\r\n{code}","component":"SonarJava","component_version":"4.3"}