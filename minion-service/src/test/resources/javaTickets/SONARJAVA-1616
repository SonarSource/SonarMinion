{"description":"Detection of unchecked conversion is not able to make the distinction between an internal call and a call on a raw type. \r\n\r\n {code} \r\nclass G\u003cT\u003e {\r\n\r\n  private G\u003c?\u003e type() {\r\n    return null;\r\n  }\r\n\r\n  void foo() {\r\n    G\u003c? super T\u003e plop \u003d (G\u003c? super T\u003e) type(); // type of the method invocation is a ClassJavaType G instead of G\u003c?\u003e (this results in false positive for redundantTypeCastCheck)\r\n  }\r\n\r\n {code} \r\nUnchecked call when raw type of argument is used is also not taken in consideration to correctly compute the return type of a method (based on erasure) : \r\n{code}\r\n\u003cT\u003e List\u003cT\u003e foo(A\u003cT\u003e a){}\r\n...\r\nfoo(new A()); // unchecked call -\u003e erasure of return type should be used. cf JLS \r\n{code}\r\n\r\nThis can also produce false positives on S1905 : \r\n\r\n{code}\r\n  public static String paramsErrorMessage(Class clazz, String message) {\r\n    return \"Check jproperties:\" + ((Rule) clazz.getAnnotation(Rule.class)).key(); // false positive as the cast is required because return type is annotation because clazz is raw type.\r\n }\r\n{code}\r\n","component":"SonarJava","component_version":""}