{"description":"In the following code, the method which is called in the body of the constructor is declared within the class and marked as final, the method invocation is however not properly resolved, as we identify the method invocation has being a call to the method from the interface, and not the method declared in A.\r\n\r\n{code}\r\npublic class A implements I {\r\n  public A() {\r\n    foo(String.class); // resolved to I.foo(...)\r\n  }\r\n\r\n  @Override\r\n  public final \u003cT\u003e T foo(Class\u003cT\u003e clazz) { // not resolved as being used in constructor\r\n    return null;\r\n  }\r\n}\r\n\r\ninterface I {\r\n  public \u003cT\u003e T foo(Class\u003cT\u003e clazz);\r\n}\r\n{code}\r\n\r\nThe problem is probably due to type resolution of the type corresponding to {{String.class}} and the subsequent resolution of the parametric method.\r\n\r\nIf we remove the parameter to have a method {{foo()}} without parameter. The called method is correctly resolved.\r\n\r\n{code}\r\npublic class A implements I {\r\n  public A() {\r\n    foo(); // correctly resolved to A.foo()\r\n  }\r\n\r\n  @Override\r\n  public final void foo() {  }\r\n}\r\n\r\ninterface I {\r\n  public void foo();\r\n}\r\n{code}","component":"SonarJava","component_version":"5.4"}