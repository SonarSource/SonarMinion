{"description":"In the following code, we consider that the equality tests will always be true (same Symbolic Values on both side of the expression), but that\u0027s not the case. \r\n\r\nAs long as the primitive values are not mapped to primitive wrappers, a comparison from {{NaN}} (Not a Number) with {{NaN}} will always be false. Once wrapped, however, comparison are done by reference and the test is then always true (as reported).\r\n\r\n\r\n{code}\r\n  void foo() {\r\n    double d \u003d Double.NaN;\r\n    /*\r\n     * following codes always raises 2 issues:\r\n     * - squid:S1764 (identical sub expressions on both side)\r\n     * - squid:S2589 (condition always true)\r\n     */\r\n    if (d \u003d\u003d d) { // False Positive: NaN is even false when compared to itself\r\n      foo();\r\n    }\r\n    Double bigD \u003d d;\r\n    if (bigD \u003d\u003d bigD) { // True Positive: Once wrapped into Double, equals is going to be always true\r\n      foo();\r\n    }\r\n\r\n    float f \u003d Float.NaN;\r\n    if (f \u003d\u003d f) { // False Positive\r\n      foo();\r\n    }\r\n    Float bigF \u003d f;\r\n    if (bigF \u003d\u003d bigF) { // True Positive\r\n      foo();\r\n    }\r\n  }\r\n{code}","component":"SonarJava","component_version":""}