{"description":"The type of the lambda expression, once infered, should propagate to the calling method when applicable in order to infer deferred types.\r\n\r\nIn the following example, the first map operation, calling method {{test1}} trigger type inference, resulting with type {{Function\u003c? super String, boolean\u003e}}\"  (should probably be {{Function\u003c? super String,? extends Boolean\u003e}}) being associated to the lambda expression. \r\n\r\nThe return type of the {{map}} method invocation is however still deferred. What we learn from the lambda should allow to infer its type to {{Stream\u003cBoolean\u003e}}. The type being currently not inferred, we are not able to resolve following method invocations.\r\n\r\n{code}\r\nclass Foo {\r\n\r\n  public void foo(java.util.List\u003cString\u003e list) {\r\n    list.stream()\r\n      .filter(s -\u003e (s.length() \u003e 42))\r\n      .map(s -\u003e test1(s)) // test1 correctly resolved\r\n      .map(b -\u003e test2(b)); // test2 not resolved\r\n\r\n    list.stream()\r\n      .map(String::length)\r\n      .filter(x -\u003e test3(x) \u003e 0); // test3 not resolved\r\n  }\r\n\r\n  private boolean test1(String s) {\r\n    return false;\r\n  }\r\n\r\n  private int test2(boolean b) {\r\n    return 0;\r\n  }\r\n\r\n  private int test3(int x) {\r\n    return x - 1;\r\n  }\r\n\r\n}\r\n{code}","component":"SonarJava","component_version":"4.2.1"}