{"description":"Current {{WildcardTree}} is not a {{TypeTree}}, and consequently have no type directly associated. However, for each {{WildcardTree}} we are actually computing a type during semantic analysis. This type is only used for the parent Parametrized type, and not associated to the WildcardTree itself.\r\n\r\nIt should be possible to access to its type directly from the tree, instead of having to go through the parent {{ParametrizedTypeTree}}, or the symbol associated to the bound, and then infer from the bound type.\r\n\r\nFrom a Java Language perspective, we can not define variables using a {{WildcardTree}} directly as type ({{? extends Foo myVar;}}), but we can still add annotations, like in any other {{TypeTree}} as we defined them.\r\n\r\n{code}\r\nimport java.lang.annotation.ElementType;\r\nimport java.lang.annotation.Target;\r\nimport java.util.List;\r\n\r\nabstract class A {\r\n  abstract void foo(List\u003c@Foo ? extends B\u003e myList);\r\n}\r\n\r\nclass B { }\r\n\r\n@Target(value \u003d ElementType.TYPE_USE)\r\n@interface Foo { }\r\n{code}\r\n\r\nIn the previous example, we should be able to subscribe to directly access the wildcard tree, and get its type directly.\r\n","component":"SonarJava","component_version":"5.3"}