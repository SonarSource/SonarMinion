{"description":"In the following cases, we are not able to correctly resolves constructors for classes {{InnerC}} and {{InnerD}}. These two cases raise the question of the type of associated to the {{this}} variable when the class is parameterized (Unable to find any reference to that in JLS, is {{this}} of raw type or parameterized with {{T}}).\r\n\r\n{code}\r\nclass A\u003cT\u003e {\r\n  public void foo(MyClass\u003cT\u003e mc) {\r\n    new InnerA\u003c\u003e((A\u003cT\u003e) this, mc); // \u0027this\u0027 is explicitly casted to the parameterized type, which should be equivalent\r\n  }\r\n\r\n  private static class InnerA\u003cU\u003e {\r\n    private InnerA(A\u003cU\u003e a, MyClass\u003cU\u003e mc) { } // correctly resolved\r\n  }\r\n}\r\n\r\nclass B\u003cT\u003e {\r\n  public void foo(MyClass\u003cT\u003e mc) {\r\n    new InnerB\u003cT\u003e(this, mc); // type argument \u0027T\u0027 is written explicitly \r\n  }\r\n\r\n  private static class InnerB\u003cU\u003e {\r\n    private InnerB(B\u003cU\u003e b, MyClass\u003cU\u003e mc) { } // correctly resolved\r\n  }\r\n}\r\n\r\nclass C\u003cT\u003e {\r\n  public void foo(MyClass\u003cT\u003e mc) {\r\n    new InnerC\u003c\u003e(this, mc); // uses diamond operator instead of argument \u0027T\u0027 \r\n  }\r\n\r\n  private static class InnerC\u003cU\u003e {\r\n    private InnerC(C\u003cU\u003e c, MyClass\u003cU\u003e mc) { } // not resolved\r\n  }\r\n}\r\n\r\nclass D\u003cT\u003e {\r\n  public void foo(MyClass\u003cT\u003e mc) {\r\n    new InnerD\u003c\u003e((D) this, mc); // \u0027this\u0027 is explicitly casted to the raw type\r\n  }\r\n\r\n  private static class InnerD\u003cU\u003e {\r\n    private InnerD(D\u003cU\u003e a, MyClass\u003cU\u003e mc) { } // not resolved\r\n  }\r\n}\r\n{code}","component":"SonarJava","component_version":""}