{"description":"{code:title\u003dcom.sample.squid_example.pkg2.A.java}\npackage com.sample.squid_example.pkg2;\n\nimport com.sample.squid_example.pkg1.B;\n\npublic abstract class A implements B {\n\n        public A () {\n                super ();\n        }\n\n        public void foo() {\n\n                System.out.println(\"Implemented foo\");\n        }\n\n        public abstract void fooA ();\n\n}\n{code}\n{code:title\u003dcom.sample.squid_example.pkg2.B.java}\npackage com.sample.squid_example.pkg2;\n\npublic class B extends A {\n        public B () {\n                super();\n        }\n\n        @Override\n        public void fooA() {\n                System.out.println(\"in B : fooA\");\n        }\n}\n{code}\n{code:title\u003dcom.sample.squid_example.pkg1.B.java}\npackage com.sample.squid_example.pkg1;\npublic interface B {\n        public void foo ();\n}\n{code}\n\nif .class file of interface B is not made available during analysis, then the interface implemented by A gets wrongly resolved to the B class in the same package.\nThis ends up by having a cycle in the hierarchy of classes and raise bad errors in the Resolve class as it assumes the class hierarchy is correct.\n\nOne idea to fix this would be to check that B is actually an interface in this case. Another lead would be to let B be resolved in the imports even if the symbol is unknown (because we know in this case that B is a type, but then what about static import of method from unknown types ?).\n\nsee: http://sonarqube.15.x6.nabble.com/JavaSquidSensor-failing-with-java-lang-StackOverflowError-td5032197.html","component":"SonarJava","component_version":""}